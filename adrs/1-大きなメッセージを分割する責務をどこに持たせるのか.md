# 1. 大きなメッセージを分割する責務をどこに持たせるのか

- 背景

  - ChatGPT にリクエストを行うとき、メッセージが大きいとエラーが生じて途中までしかレスポンスを返さなくなる
  - ただし、これはメッセージを分割して送信すれば問題なく動作するので、どこかでメッセージを適切に分割すれば問題ない
  - どこにメッセージを分割させる責務を持たせるのが良いかが問題

- 候補

  - GPT のクライアント
    - GPT に SSE でアクセスするクライアント
  - ChatGPT として機能させているクライアント
    - ChatGPT のように会話の内容を覚えることが責務として上の構造体にプラスされているクライアント
  - GPT Functions
    - GPT のメッセージやリクエストを送信した後に何かをしたりする機能群

- 決定

  - GPTFunctions にその責務を渡すと、Functions それぞれに対して設定しないといけないので、それは違う気がする
  - GPT の関心ごとなので GPT クライアントに儲けるのがいい気がする
  - ただし、今のコードから大幅に変更しないといけない点がある

    - 今は、GPTFunctions に Message を変更させてそれを ChatGPT に渡している
    - しかし、Message の長さが大きければ分割されるため、Message を変更された後に分割されては Functions の機能が薄まる
    - それならば Message に分割する責務を渡す？
    - 例えば GPTFunctions の change_request をイミュータブルなものではなく、Message から Message を返すものにしてそれを map とかで使い回す？
    - そもそも Functions を使う関数がないのが悪い気もする
    - そもそも Functions と ChatGPT が密に連携してないけど、ChatGPT は Functions を取る様にしてもいいかも
      - chat_with_function みたいな感じで
    - Functions と Chat を引数にとる関数あってもいいのかも？
    - ただ、file のやつは path だったメッセージを初めてファイルコンテンツをメッセージとして変換するので、file パスの時点では文字数はオーバーじゃないが、そのあとでオーバーになるので、どうしたものか
    - 以下の様にしたらどうか
    - FunctionArg(String) -> Message -> (Message)-> Message -> Handle ->ActionToEnd

    ```rust
    fn arg_to_message(arg FunctionArg) -> Message
    fn change_message(mes Message)-> Message
    fn handle_stream()
    fn action_to_end
    ```

  - ただ、Client と Chat は ChatGPT に通信するってのが責務だったり、会話内容をお覚えておくのが責務って考えると、メッセージ分割は責務外な気もしている
  - でも GPT 自体の関心ごとだから Client が持っていてもいいのかな
  - でも Client は違う気がしてきた
  - なぜなら Client 自身が複数回リクエストを行うってのは少しリッチすぎる気がする
  - Chat の昨日も違うのでは？そもそも、会話することと、問い合わせ内容を分割することは異なる関心ごとのはず
  - でも Functions にはすべてその機能を持たせたい...
  - 難しいな
  - Message は GPT のメッセージを表しているので、文字数制限に関しては責務として持たせてもいい気がしている
  - それか別の関数を作るか
  - 拡張性を持たせるのであれば別の関数で切り出すのはアリな気がする
  - change_request のあとのメッセージを分割できればいいのかもしれんが、change_request で加工が消えてしまうのがなんとも言えない
  - なので、やはり、インプットを大きなメッセージに変える関数と、その後にそのメッセージを変える関数の二つが必要？でもそれって意味は分かりにくいよね
  - Message 本体を賢くして、分割するロジックをそいつに持たせるのはありかもしれん

- GPTFunctions に固執しなければいい気もしてきた
- 普通に今のまま、関数型的に実装すればいいのでは？
- やっぱ Message のなかに inner みたいな Vec<String>みたいなもの作って、こいつに対して ChangeRequest していけばいいのでは？
- そして Message のなかに対して
- chat で request の配列に対して実行を行う
- Message の中で Split の機能を持たせて、Functions のなかでそれを適宜使いたいなら使うにすればよくね？
- Functions の返り値は Vec<Message>がいい気がするし、Functions の引数は Message ではなく UserInput みたいな別の type の方がドキュメント性はいいのでは？
- これでいけばクライアントとかを変えずに実装できて、いい気がする

- なぜかレスポンスが帰ってこないことがある

  - これに対してどうするか、リトライ機構や、タイムアウトの機構をどこに持たせるか

- それかコネクションの問題もあるので、並列処理をしてあげるのも手かもしれない

  - ただし join は必要

- タイムアウトを考えると並行性の話は相当重要な気がする
  - 並行に時間を管理しておいて、時間が来たらタイムアウトするといったことが必要なので j
